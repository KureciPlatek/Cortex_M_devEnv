
In this page, I explain only the few changes I had to do to port my prj_h7 project, with `ThreadX`  on an stm32f4.
# From STM32H7 to STM32F4

List of modified source files:

| File in prj_h7                       | File in prj_f4                       | Role                                            |
| :----------------------------------- | ------------------------------------ | ----------------------------------------------- |
| `./STM32H723.svd`                    | `./STM32F411.svd`                    | Debug file                                      |
| `./stm32h7_debug.cfg`                | `./stm32f4_debug.cfg`                | Debug file                                      |
| `./startup/startup_stm32f411.s`      | `./startup/startup_stm32f411.s`      | Startup file                                    |
| `./link/STM32H723ZGTX_FLASH.ld`      | `./link/stm32f411retx_flash.ld`      | Linker file                                     |
| `./app/system_stm32h7xx.c`           | `./app/system_stm32f4xx.c`           | See[[#`arm-none-eabi`]]                         |
| `./app/stm32h7xx_hal<****>.*`        | `./app/stm32f4xx_hal<****>.*`        | STM HAL files (family dependent)                |
| `./system/tx_initialize_low_level.S` | `./system/tx_initialize_low_level.S` | ThreadX low level file (architecture dependent) |
| `./system/stm32h7xx_<****>.*`        | `./system/stm32f4xx_<****>.*`        | STM32 interrupt files (family dependent)        |

#### `arm-none-eabi`

As said earlier in this documentation, we are programming "bare-metal", which means no operating system. But functions like `malloc()`, `printf()`, `fopen()` and so on, from a C library like `newlib`, requires some very low functions, like `_write`, `_sbrk`, `_close`, `_read` ,to be implemented. But on a bare-metal, with no OS, it is nowhere to be found.

For this reason, `syscalls.c` and `sysmem.c` exists. They implement a _VERY_ basic version of those functions, or just are empty bodies, just for compilation to work. `syscall.c` stands for system call and `sysmem.c`, for system memory. The programmer is actually free to implement those functions as he wants. 

For example `printf()` requires a `_write()` function. It is implemented in `syscall.c`:

```C
__attribute__((weak)) int _write(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    // Here, __io_putchar() could be defined somewhere in our program, to send the character through UART. Therefore, when calling printf(), we will redirect stream of character to a defined UART communication.
    __io_putchar(*ptr++);
  }
  return len;
}
```

>[!NOTE]
>Those functions are all defined/declared with `__attribute__((weak))` for user to be able to redefine it somewhere in its own code, without having an "already declared" conflict form compiler 

#### ThreadX modifications

The main idea is to point to Cortex-M4 architecture (STM32F4 family) instead of Cortex-M7 (STM32H7 family).

**`SysTick()` and `HAL_tick()`**

For `ThreadX` to work, it requires the Cortex-M's internal tick interrupt: `SysTick()`, to call its scheduler. It is indeed defined/used in `tx_initialize_low_level.S` file as follow:

```C
    PUBLIC  SysTick_Handler
    PUBLIC  __tx_SysTickHandler
__tx_SysTickHandler:
SysTick_Handler:
;
; VOID SysTick_Handler (VOID)
; {
;
    PUSH    {r0, lr}
#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_enter             ; Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_exit              ; Call the ISR exit function
#endif
    POP     {r0, lr}
    BX      LR
; }
    END
#endif
```

The problem is that HAL also requires a "tick interrupt", the `HAL_IncTick()`, for its delays and other functions to work. 

When no RTOS is used on an STM32 using HAL, the `SysTick()` is used to call `HAL_IncTick()`. But calling both `ThreadX`'s scheduler and `HAL_IncTick()` in the same function is very dangerous, as it could lead to a deadlock.

For this reason, the programmer must configure and use another timer from the available timers of microcontroller and call `HAL_IncTick()` in it. Instead of in `SysTick()`

For STM32H7, TIM6 was used, but for STM32F4, I had to use TIM2. I actually don't remember why, sorry about that.

Snippet of TIM2 interrupt in file `stm32f4xx_it.c`:

```C
void TIM2_IRQHandler(void)
{
   if ((htim2.Instance->SR & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
   {
      /* Clear IRQ flag */
      __HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_UPDATE);
      /* Here is called HAL's "tick" */
      HAL_IncTick();
   }
}
```


>[!TIP]
>I had to take the `tx_initialize_low_level.S` generated by STM32CubeIDE, as it slightly changes from STM32H7 (different interrupt vector table, `SYSTEM_CLOCK` variable, use of `tx_user.h` file and some preprocessor switches)
>Normally, take the Cortex-M4 template from `ThreadX` official repository should also be fine

#### Modifications for `openOCD`

To debug with `openOCD` as a `gdb-server`, only three modifications are to be made:
- File name is now `stm32f4_debug.cfg` (is actually optional, as long as you call the right one)
- Modify `CHIPNAME` to be `STM32F411RETx`
- Select stm32f4's config file from `st_target/` in `openOCD` install directory: `source [find st_target/stm32f4x.cfg]`


#### How to get the different files:

- I still had to create a full STM32F411 project with STM32CubeMX to generate all startup files, first main and clock config, etc... I could have done it manually, but it takes too much time.

- Select for F411 in STMicroelectronics website, STM32F4, CAD page: [STM32F411 - STMicroelectronics](https://www.st.com/en/microcontrollers-microprocessors/stm32f411.html#cad-resources)

- I had to clone the STM32F4 HAL: https://github.com/STMicroelectronics/STM32CubeF4.git to get STM32F4 HAL

#### Other modifications:

I had to modify GPIO ports, GPIO RCC and so on to match STM32F411REx's config on Nucleo board.

So in functions:
- `SystemClock_Config()`
- `HAL_UART_MspInit()`
- Some defines in `board.h`


>[!Conclusion]
>There are some changes to be done to port ThreadX project from stm32h7 to an stm32f4 on another board, but it was not very complicated, as long as it is understood what is to be done and the differences between them. It took me an afternoon to port the project.

# Run program

The program is quite easy and consists of three tasks:

`MsgSenderThreadOne_Entry()`, `MsgSenderThreadTwo_Entry()` and `MsgReceiverThread_Entry()`. It is based on the example of STM32H7 `ThreadX`, but ported to an F4 family.

It all worked fine, a deeper explanation about it won't be done here, as it would be too long and is not the purpose of this article.

#todo add picture of output.